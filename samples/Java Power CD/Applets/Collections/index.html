<HTML>
<head>
<TITLE>
Overview of the collections Package
</TITLE>
</head>
<body>


<H1>
Overview of the <CODE>collections</CODE> Package
</H1>


<P> by <A HREF="http://g.oswego.edu/dl/"> Doug Lea</A>.  

<P>
This overview is intended to accompany version 0.95b of the package of
code
(<A HREF="ftp://g.oswego.edu/pub/java/collections.tar.gz">tar.gz format</A>) 
(<A HREF="ftp://g.oswego.edu/pub/java/collections.zip">zip format</A>) 
and <A HREF="collections.html">documentation </A>
for the java collection classes. Please send comments and questions to
<a href="mailto:dl@cs.oswego.edu">dl@cs.oswego.edu</a>. 

<P> (Note: This package is fairly stable and in routine use.  However,
there may continue to be minor changes. For example, because of
changes introduced in JDK-beta2, previous user-visible uses of
<CODE>clone</CODE> were changed to <CODE>duplicate</CODE>.)

 <P>
<H3>Contents</H3>
<OL>
<LI> <A HREF="#secCollections">Collections</A>
<LI> <A HREF="#secUpdatable">Updatable Collections</A>
<LI> <A HREF="#secImmutable">Immutable Collections</A>
<LI> <A HREF="#secExceptions">Exceptions</A>
<LI> <A HREF="#secEnumerations">Enumerations</A>
<LI> <A HREF="#secChecked">Checked Classes</A>
<LI> <A HREF="#secSource">Links to Source Code</A>
<LI> <A HREF="#secTodo">ToDo List</A>
<LI> <A HREF="#secHistory">Version History</A>
</OL>


<H2>
<A NAME="secCollections"></A>
Collections
</H2>

 <P> Collections are objects that hold other objects that
are accessed, placed, and maintained under some set of rules.  There
are many different ways you could classify these different rules. This
package uses one of the simplest, splitting them into four main categories,
(Sets, Bags, Seqs, Maps), plus a few `mixin' variants.  
Top-level functionality is described entirely via <CODE>interfaces</CODE>,
<EM>not</EM> <CODE>classes</CODE>. This allows some mixing
and matching of capabilities at the implementation level, and
also enables you to add your own alternative implementations 
of this functionality that will interoperate with the versions
provided in this package.
<P>
As a <EM>user</EM> of the <CODE>collection</CODE> package, you
do not need to know a lot about data structures, but you do
need to know what kinds of access and placement rules you
want in a particular situation. The basic choices are:
<UL>
<LI> Sets contain at most one occurrence of any element.

<LI> Bags may contain multiple occurrences of any element.

<LI> Seqs are ordered, and have elements that are accessible 
     via array-like indices.

<LI> Maps associate unique keys with each element.


<LI> ElementSorted Collections maintain elements in order
     with respect to a given Comparator (sorting) function;
     KeySorted collections maintain them in order of their keys.
     (Any of the above kinds of collections may be element-sorted,
      but only Maps can be key-sorted.)
</UL>


<P> 
The base interface <CODE>Collection</CODE> reflects commonalities
across all of these of kinds of rules. For reasons described below,
all of the interfaces in the following diagram describe
classes/objects that need not even be updatable (modifiable), so
restrict themselves to operations that report properties of
Collections or build new Collections with various properties.

<IMG SRC="CollIfc.gif">

 <P>
<DL>
<DT> <A HREF="collections.Collection.html">Collection</A>
<DD> Collection is the base interface for all collection classes defined
 in this package.  Every collection can:

 <UL>
 <LI> Report its <CODE>size</CODE> and whether it <CODE>isEmpty</CODE>. <P>

 <LI> Report whether it <CODE>canInclude</CODE> a given
      value. In general Collections hold
      Objects. Elements may be subclasses of Object, but
      not builtin scalars like int. 
      You can, however, use numbers as elements via
      the java.lang.Number class (or rather its subclasses) to
      ``wrap'' the numbers as number-holding objects first. For example:
 <PRE>
 void addFloat(UpdatableBag b, float f) {
   b.add(new Float(f));
 }
 </PRE> 
      <P>
      Also, null is never a valid element, so canInclude(null) is
      always false.
      Operations screen for nulls, and raise exceptions upon attempts
      to add them to collections (but NOT when testing for their presence).
      This can be annoying, but is the most defensible policy.
      One reason that nulls are excluded is that some collection operations
      intrinsically rely upon operations Object.equals and Object.hashCode,
      neither of which apply to nulls. 
      <P>
      Any given collection may make stronger demands on the
      kinds of elements it will accept, and report this via
      <CODE>canInclude</CODE>.
      Most implementation
      classes support a constructor with an argument supplying an element 
      screener (an object of type 
      <A HREF="collections.Predicate.html">Predicate</A>) that checks 
      whether a value is considered to be a potentially
      legal element of the collection. For example, you 
      could supply a screener that requires
      that all elements be Strings (using `instanceof').
      Screeners provide a more flexible variant of
      constraints found in languages with parameterized
      types, although without any kind of <EM>compile</EM> time
      guarantees that clients won't <EM>try</EM> to place inappropriate
      elements into collections, thus causing exceptions.
 <P>
 <LI> Report whether it <CODE>includes</CODE> a given element.
      Equality is always tested using Object.equals(Object other). <P>

 <LI> Report the number of <CODE>occurrencesOf</CODE> a given
      element it holds.  <P>

 <LI> Produce an <A HREF="#secEnumerations">enumeration</A> of its <CODE>elements</CODE>.  The
      enumeration returned is of type 
      <A HREF="collections.CollectionEnumeration.html">
      CollectionEnumeration</A>, a
      stronger kind of enumeration than java.util.Enumeration. <P>

 <LI> Perform <CODE>checkImplementation</CODE>, that checks
      the consistency and properties of the internal state of a
      collection implementation object. <CODE>Collection</CODE> is a 
      subinterface of 
<A HREF="collections.ImplementationCheckable.html">
ImplementationCheckable</A>, which is in turn a subinterface
of <A HREF="collections.Assertable.html">Assertable</A>, the base
interface for classes with an <CODE>assert</CODE> method that can
be used to help track down errors.  <P>
 
 <LI>  Report whether it has the <CODE>sameStructure</CODE> as
       another Collection, c; that is whether c has the same
       size and the same elements() arranged in a compatible way. This is
       a form of equality test, but is not named <CODE>equals</CODE>
       (and thus does not override Object.equals) since it is not
       always the sense of equality that you would want to apply
       to collections. <P>


 <LI>  Build a new Collection that is just like self except 
        <CODE>excluding</CODE> (i.e., removing all <CODE>occurrencesOf</CODE>)
        a given element. This does <EM>not</EM>
        alter the Collection itself, it just makes a new one. This operation
        is a lot like <EM>subtraction</EM> of numbers. When you
        say <CODE>a - b</CODE> for two numbers <CODE>a</CODE> and 
        <CODE>b</CODE>, you get a new number that represents
        the difference between them without changing 
        <CODE>a</CODE> or <CODE>b</CODE>. The <CODE>excluding</CODE>
        operation has the same kind of effect. 
         By convention, all such creational methods are named with gerunds
         (e.g., including, excluding,  adding).
        <P>
        If you want a collection
        in which you actually change the contents of the current collection
        rather than building a new one,
        you'll need an <A HREF="#secUpdatable">UpdatableCollection</A> with 
        an <CODE>exclude</CODE>
        operation, described below. But even without using UpdatableCollections,
        you can still create <EM>series</EM> of collections, each one
        differing them the previous one by virtue of not including
        a given element via code like:

        <PRE>
        Collection excludingElements(Collection c, Enumeration e) {
          while (e.hasMoreElements()) 
            c = c.excluding(e.nextElement());
          return c;
        }
        </PRE>

         <P>
        For many implementations of Collection, this is a ridiculously
        slow way to do it. However, as described below, others 
        (the Incr classes) are tuned to do this reasonably efficiently. <P>
 

 <LI>  Build a new Collection that is just like self except 
        <CODE>removingOneOf</CODE> (i.e., removing at most one
        occurrence of) a given element. <P> 

 <LI>  Build a new Collection that is just like self except 
        <CODE>replacingOneOf</CODE> (i.e., at most one
        occurrence of) some old value with a new value. <P>
       

 <LI>  Build a new Collection that is just like self except 
        <CODE>replacingAllOf</CODE> (i.e., all 
        occurrences of) some old value with a new value. <P>


  <LI> Build a <CODE>duplicate</CODE> of self -- an independent
       copy of the collection, but not
       necessarily its elements. Elements themselves
       are not necessarily cloned. (Note: <CODE>duplicate</CODE> 
       is simply the externally callable version of method
       <CODE>java.lang.Object.clone()</CODE>.)

 <LI> Also, while it cannot be stated in the interface, each collection
   implementation supports:
       <OL>
       <LI> A default constructor, initializing it to an empty
             (and unscreened) collection;
       <LI> Synchronization. As a rule, all operations (even
             ``read-only'' operations) within implementation
             classes are declared as synchronized.
       </OL>
 </UL>

<DT> <A HREF="collections.Set.html">Sets</A>
<DD> Sets are collections in which the number of occurrences of 
     any object is at most one. They support an operation that 
     causes <CODE>includes</CODE> to be true; i.e., adding an 
     element only if it is not present.

<DT> <A HREF="collections.Bag.html">Bags</A>
<DD> Bags may contain multiple occurrences of each element.
 Bags can do anything that Sets can and more, except that they
 do not intrinsically guarantee that the number of occurrences of any element
 is at most one. (However, you can always use a Bag in a way that
 `manually' enforces that the number of occurrences is at most one.)

<DT> <A HREF="collections.Seq.html">Seqs</A>
<DD> Seqs maintain elements in sequential order.  
 They are sequential lists that can be accessed by positional
 indices ranging from 0..size()-1. Other Collections that are not
 Seqs may guarantee some kind of sequential ordering
 of elements, but don't support access of these elments via
 indices.

<DT> <A HREF="collections.Map.html">Maps</A>
<DD> Maps are collections in which each element has a key.  Any kind
 of Object may serve as a key for an element.  (While you could
 use regular Collections in which each element holds a pair,
 Maps are generally simpler, more efficient, and contain
 operations useful under the interpretation that the pairs
 represent keyed elements.) 
 <P>
 Maps also serve as a way to use a certain field of objects of some 
 class as a key for purposes of storing in a collection.
 For example, supposing you want to use some accessor prop() defined in
 your class as the basis for entering and finding elements,
 you could use a Map, entering pairs of (x.prop(), x). <P>

<DT> <A HREF="collections.ElementSortedCollection.html">ElementSortedCollections</A>
<DD> A mixin for collections that always maintain elements in sorted order
     with respect to a give <A HREF="collections.Comparator.html">Comparator</A>
     Note: SortedCollections rely on the ordering properties of
     elements <EM>NOT</EM> to change once they have been placed in
     the collection. They cannot in general deal with cases
     where you change any of their
     elements behind their backs in ways that break their sort order. 
     (See however, <A HREF="#secChecked"> implementation checks</A>
     that can help you discover if this occurred.)
 <P>
 ElementSorted Collections provide a different way to use 
properties of objects as their access keys.
 You can define your class to implement interface 
<A HREF="collections.Keyed.html">
Keyed</A>,
 with a method key() that returns
 the key (for example it might just return prop()). Then use
 a <A HREF="collections.Comparator.html"> Comparator</A> 
 that compares on keys(). The 
 <A HREF="collections.DefaultComparator.html">DefaultComparator</A>
 class does this automatically before trying to perform comparsions,
 but you can write your own Comparator that does this in a 
 more specialized and efficient way.) <P>

<DT> <A HREF="collections.KeySortedCollection.html">KeySortedCollections</A>
<DD> A mixin for Maps that always maintain keys in sorted order

</DL>

<H2>
<A NAME="secUpdatable"></A>
 <A HREF="collections.UpdatableCollection.html">UpdatableCollections</A>
</H2>

<IMG SRC="UpdatableIfc.gif">

 <P>
Updatable collections are `normal' mutable collections. They:

 <UL>
 <LI> Allow insertion, removal, and/or replacement of elements in
     accordance with their element semantics. Some such operations
     (like clear, take) are common to all updatable classes.

 <LI> Maintain a `version number' that changes upon each
     successful modification.

 <LI> Produce elements() enumerations that contain consistency
     checks, invalidating the enumeration if the base collection
     has been changed during the course of a traversal.
 </UL>

<DL>

<DT> <A HREF="collections.UpdatableSet.html">UpdatableSets</A>
<DD> Updatable collections maintaining Set semantics. They support
     an `include' operation that adds
     an element if not present, plus a version that includes
     all elements from a supplied Eunumeration.

<DT> <A HREF="collections.UpdatableBag.html">UpdatableBags</A>
<DD> Updatable collections with an add(v) operation, that adds 
 an occurrence of v to the collection, and addIfAbsent that only
 conditionally adds the element.

<DT> <A HREF="collections.UpdatableSeq.html">UpdatableSeqs</A>
<DD> Seqs with standard indexed update operations (insertAt, replaceAt,
 removeAt). They also support
 method <CODE>insertElementsAt(int index, Enumeration e)</CODE>
 that adds all elements of e, in order, at position index.  
 UpdatableSeqs also support special (often more efficient)
 methods operating on the front and back of the sequence,

<DT> <A HREF="collections.UpdatableMap.html">UpdatableMaps</A>
<DD> Maps with update operations, principally 
  putAt(key, element) and removeAt(key).

<DT> <A HREF="collections.SortableCollection.html">SortableCollections</A>
<DD> A `mixin' for collections that support a sort
 operation that accepts a  Comparator.
 The difference between Sorted and Sortable is that
 (Element- or Key-) SortedCollections are always in sorted order, 
 while Sortable
 ones may be sorted (via sort(Comparator cmp)), but may then
 be altered in ways so they are no longer sorted. 
</DL>

 Generally, implementations are written at the point
 in the interface hierarchy that they most naturally support.
 They mainly use classic data structure implementation techniques,
 with an emphasize safety and correctness,
 but with enough efficiency that you will not usually have
 to build your own special-case data structures.
 <P>
 Currently, there are no `wrapped' implementation types that
 allow one implementation to serve as another kind of collection.
 You can always build these yourself.
 For example, it's possible to have an RBTree serve as the underlying
 implementation for a Set by making, say, an RBSet class holding
 a reference to an RBTree, and forwarding include as addIfAbsent,
 and so on. 
 Similarly, there are not any Seq-like classes (like Stack or Queue)
 that ONLY support operations
 on the front or back, since you can just use UpdatableSeqs 
 for such purposes merely by not using those other operations;
 or if you like, making a special class holding an UpdatableSeq and
 forwarding it only selected messages.
  <P>
 The reason there are so many different implementation types
 it that, in the collections business, it's not the case
 that one size fits all. Different Implementations have
 different time/space tradeoffs, and different operations
 they are particularly good and bad at. The basic strategy
 for building a collection package is to force all of these
 implementations to share common interfaces, so that only
 the person doing the initial construction of a collection
 object that will be passed around and used polymorphically
 has to care about these issues. If you do not care, just use
 the ones handed out by 
 <A HREF="collections.DefaultImplementations.html">
 DefaultImplementations</A>, which makes
 pretty reasonable choices.  If you do care, be sure to look
 over the time complexities listed in the documentation for
 each implementation class.
 <P>
 Forcing implementations to share common interfaces is a
 standard OO trick, but sometimes leads to classes
 providing methods that they'd almost rather not support.
 For example LinkedLists support indexed access of the elements
 of the list. This is pretty slow. You'd only use a
 LinkedList if you only rarely need to access by index.
 <P>
 All current implementations are subclasses of
 <A HREF="collections.UpdatableImpl.html">UpdatableImpl</A>
 a convenient abstract class
 that provides default implementations of many UpdatableCollection
 operations. 
 <P>
 Also, all current UpdatableCollection classes implement constructive
 operations (<CODE>excluding</CODE>, <CODE>adding</CODE>, etc) by
 cloning full copies, which is not very fast.
 <P>
 Current implementations include: <P>
<DL>
<DT> <A HREF="collections.HashedSet.html">HashedSets </A>
        implement UpdatableSet
<DD> Standard implementation of hash tables of single elements.

<DT> <A HREF="collections.RBTree.html">RBTrees </A>
        implement UpdatableBag, ElementSortedCollection
<DD> Implementation of red-black trees, a form of
     balanced sorted binary search tree. 

<DT> <A HREF="collections.LinkedList.html">LinkedLists </A>
        implement UpdatableSeq, SortableCollection
<DD> Standard implementation of linked lists.

<DT> <A HREF="collections.CircularList.html">CircularLists </A>
        implement UpdatableSeq
<DD> Standard implementation of double-linked circluar lists.

<DT> <A HREF="collections.Dynarray.html">Dynarrays </A>
        implement UpdatableSeq, SortableCollection
<DD> Buffered array that dynamically resizes when necessary. 

<DT> <A HREF="collections.LinkedBuffer.html">LinkedBuffers </A>
        implement UpdatableBag
<DD> An expandable list of array-based buffers.

<DT> <A HREF="collections.HashedMap.html">HashedMaps </A>
        implement Map
<DD> Hash Table of keyed elements,

<DT> <A HREF="collections.LLMap.html">LLMaps </A>
        implement Map
<DD> LinkedLists of (key, element) pairs supporting Map operations.

<DT> <A HREF="collections.RBMap.html">RBMaps</A>
        implement Map, KeySortedCollection
<DD> Red-Black trees of keyed elements

</DL>

These implementation classes contain only methods described
in their interfaces, plus, in most cases, a few special
`tuning' methods that let you override default properties of the underlying
data structures. These include:

<UL>
<LI> Hash tables: methods to determine and set the number of
     <CODE>buckets</CODE> and the <CODE>loadFactorThreshold</CODE>.


<LI> Linked buffers: methods to determine and set the <CODE>chunkSize</CODE>
     for buffers.

<LI> Dynarrays: methods to determine and set the <CODE>capacity</CODE>
     of the underlying arrays


<LI> Red-black trees: methods to reset the <CODE>elementComparator</CODE>
     or <CODE>keyComparator</CODE> used for ordering.
     
</UL>
 
 <P>

Many of the implementation classes themselves rely on yet
 lower-level classes of basic data structures. These classes
 are also made public in this package, so that you can use
 them as the building-blocks of other Collection implementations.
 They currently include:  <P>
<DL>
<DT> <A HREF="collections.Cell.html">Cell </A>
<DD> A simple box holding an Object

<DT> <A HREF="collections.LLCell.html">LLCell </A>
<DD> Cells with next-pointers. Each cell knows how to do
     basic linked list operations like insert another LLCell
     after itself.

<DT> <A HREF="collections.LLPair.html">LLPair </A>
<DD> An extension of LLCell in which each node has a key

<DT> <A HREF="collections.CLCell.html">CLCell </A>
<DD> A cell with next- and prev- pointers, and operations so that
     objects maintain themselves in proper circular list order.

<DT> <A HREF="collections.RBCell.html">RBCell </A>
<DD> A cell with red-black-tree pointers and color, and methods
     to add new RBCells, properly rebalancing the tree it is in
     upon insertion. And so on

<DT> <A HREF="collections.RBPair.html">RBPair </A>
<DD> RBCells with keys.

</DL>
<H2>
<A NAME="secImmutable"></A>
<A HREF="collections.Immutable.html">Immutable</A> Collections.
</H2>

<IMG SRC="ImmutableIfc.gif">

 <P>
 Immutable versions of collections are those that GUARANTEE not to
 support mutations. This is a stronger claim than is made by
 Collection, since any object known only to be a Collection MAY be
 coercible to Updatable. But an Immutable version is not. This makes
 Immutable classes exceedingly safe.  
 <P>
 In Java, the <EM>concept</EM> of immutablity is best expressed as
 an in-the-small design pattern consisting of:

<OL>
<LI> A base interface describing some non-mutative functionality,
     for example our <CODE>Collection</CODE>, <CODE>Set</CODE>,
     etc., interfaces.
<LI> Implementation classes that are <CODE>final</CODE>, and support
     <EM>only</EM> the operations described in the interface. The
     use of <CODE>final</CODE> means that when you think you have
     an immutable object, you really do -- it's not of some
     subclass that supports mutable operations as well.
<LI> The use of the interface <CODE>Immutable</CODE> just
     to give a name to this property, so that, by convention,
     such classes declare <CODE>implements Immutable</CODE>.
     The actual interface <CODE>Immutable</CODE> is a null interface,
     listing no operations at all.
</OL>
 <P>
  The <CODE>collections</CODE> package currently contains four
  implementation classes using this scheme.
 <A HREF="collections.IncrSet.html">IncrSets</A>
 <A HREF="collections.IncrBag.html">IncrBags</A>
 <A HREF="collections.IncrSeq.html">IncrSeqs</A>
 <A HREF="collections.IncrMap.html">IncrMaps</A>
 are all implementation subclasses of abstract
 class  
 <A HREF="collections.IncrImpl.html">IncrImpl</A>
 that uses a `negative delta' algorithm to
 do lazy copying of collections formed via creational
 update methods. This algorithm can be applied to <EM>any</EM>
 kind of underlying UdatableCollection, so the Incr classes
 do not actually perform the underlying updates (they rely on
 UpdatableCollections supplied within constructors), they
 just arrange to do it with a minumum of actual copying.
 They normally update in a `lazy' fashion,
 making copies only when necessary. However, when you are using
 a received Immutable Collection as the basis for a very extensive set of
 update operations (none of which should be applied to the original), 
 it is sometimes more efficient
 to build an UpdatableCollection, add all of the elements of the
 received ImmutableCollection to it, and then work off that. (Also,
 the benefits of lazy updates are not always worth their costs
 for small-sized collections. For those with only a few elements,
 it is probably better to just make copies.)

 <P>
 There are two standard usage patterns for Immutable Collections:
 <OL>
   <LI> As a much stronger analog of C++ `pass by const reference';
        i.e.,  passing an updatable collection in a way that is
        guaranteed not to modify it. 
        Each of the Immutable classes supports a constructor that
        allows you to use an UpdatableCollection in an immutable fashion.
        For example, suppose
        you have a HashedSet hs, (an implementation of UpdatableSet),
        and want to send it safely to some method 
        <CODE> SomeClass.someMethod(Set s)</CODE>.
        You can do this via <CODE>c.someMethod(new IncrSet(hs))</CODE>.
        Note, however, that constancy guarantees can only hold
        so long as you don't modify hs during the course of
        the call, as might happen if someMethod creates a new thread using hs
        and then returns, so that you then continue on modifying hs.
        If this is a potenital problem, use the next option. <P>

   <LI> As representations of pure functional values (as used for example
        in languages like ML). Even though they are immutable,
        Immutable Collections still support <EM>constructive</EM> operations
        that create new collections differing from their arguments
        only in that they add, remove, or replace a given element.
        Each of the classes contain a default constructor that
        initializes them to use an appropriate DefaultImplementations object.

</OL>
<P>
 One of the main reasons for supporting all of the operations
 that make Immutable Collections possible is to provide tools
 that help keep threads from stomping on each others collections.
 This can be a serious problem in multithreaded Java programs.
 Synchronization (which is supported by
 all implementation classes) helps, but not enough to
 avoid some common errors. Immutable collections help even more. They let
 you pass around values that cannot be modified at all in
 other threads without you having to make full copies of them
 when you don't need to. This is the same reasoning
 that led to Java having two classes for Strings: <CODE>String</CODE>
 for pure immutable strings, and <CODE>StringBuffer</CODE> for
 updatable ones. 


<H2>
<A NAME="secExceptions"></A>
Exceptions
</H2>

Collection methods are defined to throw only a small 
      number of exception types: <P>

<DL>

<DT>  java.util.NoSuchElementException
<DD> Thrown for attempts to access elements that do not exist.
<DT> <A HREF="collections.IllegalElementException.html">
     IllegalElementExceptions</A> (a subclass of IllegalArgumentException)
<DD> Thrown for attempts place null or invalid elements.
<DT> <A HREF="collections.CorruptedEnumerationExceptions.html">CorruptedEnumerationExceptions </A>
(A subclass of NoSuchElementException)
<DD> Thrown for attempts to access elements in enumerations that have been
      detectably compromised because the collection serving as the
      base of the collection has been modified in the course of traversal.
<DT> <A HREF="collections.ImplementationError.html">ImplementationErrors</A>
     (a subclass of Error)
<DD> Thrown for detected failures due to coding errors (i.e., cases in
      which internal consistency checks or required postconditions fail).
<DT> java.lang.IllegalArgumentException
<DD> Thrown for other bad arguments.

</DL>
 <P>
Except for operations that accept Enumerations as arguments
(for example UpdatableSeq.addElementsAt), exception throws generated
from Collection operations are always accompanied by state ``rollbacks''.
That is, they
leave the object in a behaviorally equivalent state as it was
before the operation commenced. (Operations accepting Enumerations
may rollback, but do not promise to.)


<H2>
<A NAME="secEnumerations"></A>
Enumerations
</H2>

Enumerations are the ``common currency'' of collections. Enumerations
are generally ``lightweight'' and simple to use, not only within
this package, but also across other Java classes that use the
<CODE>java.util.Enumeration</CODE> interface. 
Because  Collection methods use Enumerations as
the basic element access construct, classes in this
package are generally compatible with other existing Java collection
classes.  (Although by necessity, there is some
duplication. For example, Dynamic array implementations are
very similar to java.util.Vector, but different enough that they
needed to be redone from scratch.) 

 <P>
All <CODE>Collection</CODE> classes actually produce
<CODE>CollectionEnumerations</CODE> to report elements.
<A HREF="collections.CollectionEnumeration.html">
CollectionEnumeration</A> is a subinterface of the standard
<CODE>java.util.Enumeration</CODE> that adds two methods:
<CODE>corrupted</CODE> which reports true if the enumeration is
detectably corrupted because of mutative operations occurring during
traversals, and <CODE>numberOfRemainingElements</CODE>, which
reports the number of elements yet to be traversed.


<P> While they are handy, Enumerations sometimes require a bit of
care.  Any <CODE>CollectionEnumeration</CODE> produced by an
<CODE>UpdatableCollection</CODE> can become <CODE>corrupted</CODE> if
an update operation on the collection is performed during a traversal.
The standard implementation of <CODE>CollectionEnumeration</CODE>
classes is very conservative, and reports corruption if there is
<EM>any</EM> change in the elements() set (as reflected by
<CODE>version</CODE> changes). Thus, any attempt to obtain a
<CODE>nextElement</CODE> can fail, raising a
CorruptedEnumerationException.  (Enumerations produced from
<CODE>Immutable</CODE> collections can only fail in this way if they
were constructed around an UpdatableCollection that remains
asynchronously accessible via other means even after it has been
wrapped within an Immutable Collection.  As discussed elsewhere, while
it is impossible to enforce, Immutable Collections should never be
used in this way to begin with.)

<P> Corruption exceptions occurring during operations such as
<CODE>Bag.addElements()</CODE> are particularly tricky to revover
from. Upon exceptions, these operations do not necessarily ``roll
back'' to the state they were in before the operation, so recovery is
hard to manage. (Although you can at least look at
<CODE>numberOfRemainingElements</CODE> to find out how many elements
were not processed.) If you are worried about such problems, set up
your own code to manually traverse enumerations and perform the inner
operations, but recovering in special ways upon exception.

<P>
You sometimes need to adjust standard algorithms to avoid the
possibility of CorruptedEnumerationExceptions. For example, if
you want to traverse through s.elements() for <CODE>Set s</CODE> and 
add other new elements depending on what's there, you CANNOT do it
via code like:
<PRE>
  void f(UpdatableSet s) { // DO NOT DO THIS
    Enumeration e = s.elements();
    while (e.hasMoreElements()) 
      if (someProperty(e.nextElement())) 
        s.include(someNewObject()); // will cause exception for nextElement
  }
</PRE>

<P>
One alternative is to place new elements in an auxilliary collection
during the traversal; for example:
<PRE>
  void f(UpdatableSet s) { 
    UpdatableBag aux = new LinkedBuffer();
    Enumeration e = s.elements();
    while (e.hasMoreElements()) 
      if (someProperty(e.nextElement())) 
        aux.add(someNewObject()); 
    s.includeElements(aux.elements()); // add them all at once   
  }
</PRE>
 <P>
Or, you could instead use an ImmutableSet, returning the ultimate
result:

<PRE>
  Set f(Set s) { 
    Enumeration e = s.elements();
    while (e.hasMoreElements()) 
      if (someProperty(e.nextElement())) 
        s = s.including(someNewObject()); 
    return s;
  }
</PRE>
 <P>
Another alternative is to use a <CODE>Seq</CODE> instead
of Sets or Bags when you need to use such algorithms,
and use indexing instead of element() traversals. For example:

<PRE>
  void f(UpdatableSeq s) { 
    int originalSize = s.size();
    for (int i = 0; i &lt; originalSize; ++i)
      if (someProperty(s.at(i)) 
        s.insertLast(someNewObject()); 
  }
</PRE>

 <P>

Very few collection operations deal with other collections. Most
instead deal with Enumerations. For example, there is no such
operation as <CODE>UpdatableSet.union(Set s)</CODE> to union in the
elements of another <CODE>Set s</CODE>. Instead there is
<CODE>UpdatableSet.includeElements(Enumeration e)</CODE> that can be
used to the same effect (via
<CODE>includeElements(s.elements())</CODE>), but can also be used to
include any set of Objects traversable from an any kind of Enumeration.
 <P>
It is probably good practice to design methods and classes that use
the <CODE>collections</CODE> package to also take Enumerations as
arguments and return them as results instead of only accepting other
collections. This increases the range of application of your classes.
 <P>
Several specialized Enumeration classes are available to make
it easier to deal in Enumerations rather than Collections or
other special data structures. They include:

<DL>
<DT> <A HREF="collections.ArrayEnumeration.html">ArrayEnumeration</A>
<DD> A utility class that allows you to traverse arrays as
     enumerations. For example:
 <PRE>
  Object arr[] = { new Float(1.0f), new Float(2.0f) }
  Dynarray s = ...
  s.insertElementsAt(0, new ArrayEnumeration(arr));
 </PRE> 
 <P>
<DT> <A HREF="collections.FilteringEnumeration.html">FilteringEnumeration</A>
<DD> A class that allows you to ignore elements in an enumeration
     that don't meet some criterion (expressed as a
     <A HREF="collections.Predicate.html">Predicate</A>).
  For example, if you want to screen out everything but Panel
  objects from a collection coll that might hold things other than Panels,
  write something of the form:
  <PRE>
  Enumeration e = coll.elements();
  Enumeration panels = new FilteringEnumeration(e, new IsPanel());
  while (panels.hasMoreElements()) 
   doSomethingWith((Panel)(panels.nextElement()));
  </PRE>
  To use this, you will also need to write a little class of the form:
  <PRE>
  class IsPanel implements Predicate {
   boolean predicate(Object v) { return (v instanceof Panel); }
  }
  </PRE>
 <P>
<DT> <A HREF="collections.MappingEnumeration.html">MappingEnumeration</A>
<DD> A class that allows you to  transform elements from
     other enumerations before they are seen by their `consumers'
     by invoking an arbitrary <A HREF="collections.Function.html">Function</A>)
     on each <CODE>nextElement</CODE> access. 
  For example, if you want to process only the parent() fields
  of java.awt.Component elements held by a collection coll
  you could write something of the form:
  <PRE>
  Enumeration e = coll.elements();
  Enumeration parents = new MappingEnumeration(e, new ParentFunction());
  while (parents.hasMoreElements()) 
   doSomethingWith((Container)(parents.nextElement()));
  </PRE>
  To use this, you will also need to write a little class of the form:
  <PRE>
  class ParentFunction implements Function {
   Object function(Object v) {
     if (v instanceOf Component) return ((Component)v).getParent();
     else return null;
   }
  }
  </PRE>
 <P>
  (You might also interpose a FilteringEnumeration here to screen
  out the resulting nulls.)  
  <P>
  All this requires too much set-up to be reasonable in most
  situations, but is invaluable in others. <P>

<DT> <A HREF="collections.InterleavingEnumeration.html">InterleavingEnumeration</A>
<DD> A class that allows you to  
  combine the elements
  of two different enumerations as if they were one enumeration
  before they are seen by their `consumers'.
  This sometimes allows you to avoid having to use a 
  Collection object to temporarily combine two sets of Collection elements()
  that need to be collected together for common processing.
  <P>
  The elements are revealed (via nextElement()) in a purely
  interleaved fashion, alternating between the first and second
  enumerations unless one of them has been exhausted, in which case
  all remaining elements of the other are revealed until it too is
  exhausted. 
  <P>
  For example, if you want to process together the elements of
  two Collections a and b, you could write something of the form:
  <PRE>
  Enumeration items = new InterleavingEnumeration(a.elements(), b.elements());
  while (items.hasMoreElements()) 
   doSomethingWith(items.nextElement());
  </PRE>
 <P>
</DL>

<H2>
<A NAME="secChecked"></A>
<A HREF="collections.CheckedCollection.html">Checked </A> Collections
</H2>

 <P>
 A semiformal notation is used to try to nail down interfaces.
 This is not an exercise in formal methods. (In fact the best way
 formally  specify interfaces and operations in `open' systems like
 Java is not a completely solved issue.)
 It is instead an attempt to
 be as unambiguous as possible about the effects of
 operations, which is easier to do with a bit of formalism.
 In fact, the main reason for spelling these out is to form a
 basis for testing. Nearly all claims made about operations in
 interfaces are tested for in corresponding Checked classes. 
 So
 you can be reasonably sure that any claim made has been verified
 to hold, at least in the cases actually tested.
  <P>
 Checked versions of each of the major Updatable interfaces exist --
 <A HREF="collections.CheckedSet.html">CheckedSet </A>
 <A HREF="collections.CheckedBag.html">CheckedBag </A>
 <A HREF="collections.CheckedSeq.html">CheckedSeq </A>
 <A HREF="collections.CheckedMap.html">CheckedMap </A>.
  Each
 one `wraps' a normal collection object, and for each operation,
 asks the inner collection to perform it, checks as best it can that the effects
 match the specification, and then returns any results. When
 you have any doubt about any implementation, you can wrap it
 in a Checked version and watch for ImplementationError exceptions.
 (This is likely to slow down your program by a few orders of magnitude!)
 <P>
 Implementation classes are for the most part just informally
 documented, but contain links to the fuller descriptions of
 the methods they implement.  However, each implementation class also
 supports a <CODE>checkImplementation</CODE> operation, that
 tests for internal representational consistency. While this
 is usually required only for testing purposes, it can come in
 handy in other situations as well. For example, it can help you discover
 whether someone changed the ordering property of an element in
 a <CODE>SortedCollection</CODE> or changed it in a way that
 no longer passes <CODE>canInclude</CODE> for most other collections.
 <P>
 Constructs used in the class documentation include:
 <UL>
  <LI> <CODE>return condition</CODE> to describe 
       postconditions and effects true upon return of a method.

  <LI> <CODE>PREV(obj)</CODE> within a return condition to refer 
        to the state of an object at the onset of a method.

  <LI> <CODE>OUT(message)</CODE>  to describe messages that are
       sent to other objects as required aspects of functionality,
       or referrred to in describing the effects of other methods.
       And similarly <CODE>IN(message)</CODE> for messages that are received.

  <LI> <CODE>foreach (int i in lo .. hi) predicate(i)</CODE> to
       means that predicate holds for each value of i.

  <LI> <CODE>foreach (SomeClass x) predicate(x)</CODE> to
       means that predicate holds for each instance of SomeClass

  <LI> <CODE>foreach (Object x in e) predicate(x) </CODE> to mean 
       that the predicate holds for each element obtained
       via nextElement() for Enumeration e.

  <LI> <CODE>let v = expr in ...</CODE> to give a name to
       an expression.

  <LI> <CODE>--&gt;</CODE> to means `implies'.

  <LI> ``Behaviorally equivalent to <CODE>{ code segment }</CODE>''
       to document convenience or specialized methods that can be 
       defined in terms of the effects of more primitive methods.

  <LI> ``No spurious effects'', meaning that the changes or results listed
       are the <EM>only</EM> behavioral effects on any visible object. 
       In particular, that
       an operation does not otherwise affect the size() or elements()
       of the collection(s), and does not invoke
       <EM>any</EM> methods (except for <CODE>equals</CODE> 
       and <CODE>hashCode</CODE>) on the elements 
       held in the collection. 

 </UL>

<H2>
<A NAME="secSource"></A>
Links to Source Code
</H2>

Note: All of the code in this package carries the following header:
<p>

<pre>
  Originally written by Doug Lea and released into the public domain. 
  Thanks for the assistance and support of Sun Microsystems Labs, Agorics 
  Inc, Loral, and everyone contributing, testing, and using this code.
</pre>
<p>
This means that you can use it for any purpose whatsoever, with no
restrictions.
 
<UL>
<LI> <A HREF="ArrayEnumeration.java">ArrayEnumeration.java</A>

<LI> <A HREF="Assertable.java">Assertable.java</A>

<LI> <A HREF="Bag.java">Bag.java</A>

<LI> <A HREF="BinaryFunction.java">BinaryFunction.java</A>

<LI> <A HREF="CEImpl.java">CEImpl.java</A>

<LI> <A HREF="CLCell.java">CLCell.java</A>

<LI> <A HREF="CLEnumeration.java">CLEnumeration.java</A>

<LI> <A HREF="Cell.java">Cell.java</A>

<LI> <A HREF="CheckedBag.java">CheckedBag.java</A>

<LI> <A HREF="CheckedCollection.java">CheckedCollection.java</A>

<LI> <A HREF="CheckedMap.java">CheckedMap.java</A>

<LI> <A HREF="CheckedSeq.java">CheckedSeq.java</A>

<LI> <A HREF="CheckedSet.java">CheckedSet.java</A>

<LI> <A HREF="CircularList.java">CircularList.java</A>

<LI> <A HREF="Collection.java">Collection.java</A>

<LI> <A HREF="CollectionEnumeration.java">CollectionEnumeration.java</A>

<LI> <A HREF="Comparator.java">Comparator.java</A>

<LI> <A HREF="CorruptedEnumerationException.java">CorruptedEnumerationException.java</A>

<LI> <A HREF="DAEnumeration.java">DAEnumeration.java</A>

<LI> <A HREF="DefaultComparator.java">DefaultComparator.java</A>

<LI> <A HREF="DefaultImplementations.java">DefaultImplementations.java</A>

<LI> <A HREF="Dynarray.java">Dynarray.java</A>

<LI> <A HREF="ElementSortedCollection.java">ElementSortedCollection.java</A>

<LI> <A HREF="FilteringEnumeration.java">FilteringEnumeration.java</A>

<LI> <A HREF="Function.java">Function.java</A>

<LI> <A HREF="HTEnumeration.java">HTEnumeration.java</A>

<LI> <A HREF="HTPairEnumeration.java">HTPairEnumeration.java</A>

<LI> <A HREF="HashTableParams.java">HashTableParams.java</A>

<LI> <A HREF="HashedMap.java">HashedMap.java</A>

<LI> <A HREF="HashedSet.java">HashedSet.java</A>

<LI> <A HREF="IllegalElementException.java">IllegalElementException.java</A>

<LI> <A HREF="Immutable.java">Immutable.java</A>

<LI> <A HREF="ImplementationCheckable.java">ImplementationCheckable.java</A>

<LI> <A HREF="ImplementationError.java">ImplementationError.java</A>

<LI> <A HREF="IncrBag.java">IncrBag.java</A>

<LI> <A HREF="IncrCollectionEnumeration.java">IncrCollectionEnumeration.java</A>

<LI> <A HREF="IncrImpl.java">IncrImpl.java</A>

<LI> <A HREF="IncrMap.java">IncrMap.java</A>

<LI> <A HREF="IncrSeq.java">IncrSeq.java</A>

<LI> <A HREF="IncrSet.java">IncrSet.java</A>

<LI> <A HREF="InterleavingEnumeration.java">InterleavingEnumeration.java</A>

<LI> <A HREF="KeySortedCollection.java">KeySortedCollection.java</A>

<LI> <A HREF="Keyed.java">Keyed.java</A>

<LI> <A HREF="LBEnumeration.java">LBEnumeration.java</A>

<LI> <A HREF="LLCell.java">LLCell.java</A>

<LI> <A HREF="LLCellEnumeration.java">LLCellEnumeration.java</A>

<LI> <A HREF="LLMap.java">LLMap.java</A>

<LI> <A HREF="LLPair.java">LLPair.java</A>

<LI> <A HREF="LLPairEnumeration.java">LLPairEnumeration.java</A>

<LI> <A HREF="LinkedBuffer.java">LinkedBuffer.java</A>

<LI> <A HREF="LinkedList.java">LinkedList.java</A>

<LI> <A HREF="Map.java">Map.java</A>

<LI> <A HREF="MappingEnumeration.java">MappingEnumeration.java</A>

<LI> <A HREF="Pair.java">Pair.java</A>

<LI> <A HREF="Predicate.java">Predicate.java</A>

<LI> <A HREF="Procedure.java">Procedure.java</A>

<LI> <A HREF="RBCell.java">RBCell.java</A>

<LI> <A HREF="RBCellEnumeration.java">RBCellEnumeration.java</A>

<LI> <A HREF="RBMap.java">RBMap.java</A>

<LI> <A HREF="RBPair.java">RBPair.java</A>

<LI> <A HREF="RBPairEnumeration.java">RBPairEnumeration.java</A>

<LI> <A HREF="RBTree.java">RBTree.java</A>

<LI> <A HREF="Seq.java">Seq.java</A>

<LI> <A HREF="Set.java">Set.java</A>

<LI> <A HREF="SortableCollection.java">SortableCollection.java</A>

<LI> <A HREF="UpdatableBag.java">UpdatableBag.java</A>

<LI> <A HREF="UpdatableBagImpl.java">UpdatableBagImpl.java</A>

<LI> <A HREF="UpdatableCollection.java">UpdatableCollection.java</A>

<LI> <A HREF="UpdatableImpl.java">UpdatableImpl.java</A>

<LI> <A HREF="UpdatableMap.java">UpdatableMap.java</A>

<LI> <A HREF="UpdatableMapImpl.java">UpdatableMapImpl.java</A>

<LI> <A HREF="UpdatableSeq.java">UpdatableSeq.java</A>

<LI> <A HREF="UpdatableSeqImpl.java">UpdatableSeqImpl.java</A>

<LI> <A HREF="UpdatableSet.java">UpdatableSet.java</A>

<LI> <A HREF="UpdatableSetImpl.java">UpdatableSetImpl.java</A>

</UL>



<H2>
<A NAME="secTodo"></A>
To Do List
</H2>

<UL>
<LI> Write example applications.

<LI> Put together a decent set of applications to wrap in Checked
    and to serve as a test suite.

<LI> Add to this list.

</UL>

<H2>
<A NAME="secHistory"></A>
History
</H2>

<UL>
<LI> V0.91 Wed 11Oct95. Made public release.

<LI> V0.92 Thu 12Oct95. Fixed some documentation; Disabled questionable
     optimization in IncrImpl.


<LI> V0.93 Fri 13Oct95. Cleaned up Checked classes. Re-implemented
     copy-avoidance scheme for enumerations in Incr classes.
     Refactored to avoid PureCollection; allowing concept of
     Immutability to be applied to other classes as well.
     Made ImplementationCheckable extend Assertable.
     Fixed some protection problems. Made some interface/class
     diagrams.

<LI> V0.94 Sun 22Oct95. Added more support and utilities for enumerations.
     Fixed version-checking in Checked classes. Fixed removeAt error.
     Expanded documentation.


<LI> V0.95 Thu 14Dec95. Adjusted to new java <CODE>clone</CODE>
     conventions: Declared base classes to be Cloneable; added
     publically callable <CODE>duplicate</CODE> method.


<li> V0.95b Wed 10Jan95. Fixed error in Dynarray constructor.
</UL>

<HR>

<address>
<A HREF="http://g.oswego.edu/dl">Doug Lea</A>
</address>
<!-- hhmts start -->
Last modified: Thu Jan 11 06:15:35 EST 1996
<!-- hhmts end -->
</body> </html>
